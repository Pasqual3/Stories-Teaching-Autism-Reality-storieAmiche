import os
import subprocess
import sys
import platform
import shutil
import json
from pathlib import Path
import time
import re

def print_header(text, emoji="üöÄ"):
    print("\n" + "="*60)
    print(f"{emoji} {text.upper()}")
    print("="*60)

def print_step(step_num, total_steps, text):
    print(f"\n[{step_num}/{total_steps}] {text}")

def repair_env_file(env_file, base_path, vv_root=None, python_bin=None, venv_path=None):
    """Ripara o completa un file .env esistente con percorsi REALI"""
    
    print("\n   üîß RIPARAZIONE FILE .ENV")
    print("   " + "-"*50)
    
    # Leggi il file .env esistente
    env_vars = {}
    if env_file.exists():
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key.strip()] = value.strip()
    
    print(f"   üìã Variabili trovate: {len(env_vars)}")
    
    # ========================================
    # RILEVAMENTO AUTOMATICO PERCORSI REALI
    # ========================================
    
    # 1. Rileva VibeVoice se non passato come parametro
    if not vv_root:
        print("\n   üîç Ricerca automatica VibeVoice...")
        
        # Cerca in diverse posizioni possibili
        possible_paths = [
            base_path / "VibeVoice",
            base_path / "VibeVoice" / "VibeVoice",
            base_path.parent / "VibeVoice",
        ]
        
        for path in possible_paths:
            if path.exists() and (path / "setup.py").exists():
                vv_root = path
                print(f"   ‚úÖ Trovato: {vv_root}")
                break
        
        if not vv_root:
            print(f"   ‚ö†Ô∏è VibeVoice non trovato automaticamente")
    
    # 2. Rileva Python venv se VibeVoice esiste
    if vv_root and vv_root.exists():
        print("\n   üîç Ricerca Python virtual environment...")
        
        # Cerca venv con nomi comuni
        venv_names = ['env1', 'venv', 'env', '.venv']
        
        for venv_name in venv_names:
            test_venv = vv_root / venv_name
            
            if platform.system() == "Windows":
                test_python = test_venv / "Scripts" / "python.exe"
            else:
                test_python = test_venv / "bin" / "python"
            
            if test_python.exists():
                venv_path = test_venv
                python_bin = test_python
                print(f"   ‚úÖ Trovato: {venv_name}")
                print(f"   ‚úÖ Python: {python_bin}")
                break
        
        if not python_bin or not python_bin.exists():
            print(f"   ‚ö†Ô∏è Virtual environment non trovato in {vv_root}")
    
    # Variabili richieste con valori di default
    required_vars = {
        'MONGODB_URI': 'mongodb://localhost:27017/ProgettoTerapia',
        'PORT': '4000',
        'NODE_ENV': 'development',
        'JWT_SECRETE': None,
        'SMTP_HOST': 'smtp.gmail.com',
        'SMTP_PORT': '465',
        'SMTP_USER': None,
        'SMTP_PASS': None,
        'SENDER_EMAIL': None,
        'BACKEND_URL': 'http://localhost:4000',
        'FRONTEND_URL': 'http://localhost:5173',
    }
    
    missing_vars = []
    invalid_vars = []
    
    # Controlla ogni variabile
    print("\n   üìä Analisi variabili:")
    for var, default in required_vars.items():
        if var not in env_vars:
            missing_vars.append(var)
            print(f"   ‚ùå Mancante: {var}")
        else:
            # Controlla se ha valore valido
            if not env_vars[var] or env_vars[var] in ['your_email@gmail.com', 'your_app_password_here', 'your_16_char_app_password']:
                invalid_vars.append(var)
                print(f"   ‚ö†Ô∏è Placeholder: {var}")
            else:
                print(f"   ‚úÖ OK: {var}")
    
    # Se tutto √® OK, non fare nulla
    if not missing_vars and not invalid_vars:
        print(f"\n   üéâ File .env completo e valido!")
        return True
    
    print(f"\n   üî® Riparazione necessaria:")
    print(f"   ‚Ä¢ Variabili mancanti: {len(missing_vars)}")
    print(f"   ‚Ä¢ Variabili da correggere: {len(invalid_vars)}")
    
    repair = input("\n   ‚ùì Vuoi riparare il file .env? (S/n): ").strip().lower()
    
    if repair == 'n':
        print(f"   ‚è≠Ô∏è Salto riparazione")
        return False
    
    # ========================================
    # RIPARAZIONE
    # ========================================
    
    print("\n   üîß Riparazione in corso...")
    
    # 1. JWT_SECRETE
    if 'JWT_SECRETE' in missing_vars or 'JWT_SECRETE' in invalid_vars or not env_vars.get('JWT_SECRETE'):
        print("\n   üîê JWT Secret:")
        import secrets
        env_vars['JWT_SECRETE'] = secrets.token_urlsafe(32)
        print(f"   ‚úÖ Generato automaticamente")
    
    # 2. EMAIL
    email_needs_config = (
        'SMTP_USER' in missing_vars or 
        'SMTP_PASS' in missing_vars or 
        'SMTP_USER' in invalid_vars or
        'SMTP_PASS' in invalid_vars or
        not env_vars.get('SMTP_USER') or 
        not env_vars.get('SMTP_PASS') or
        env_vars.get('SMTP_USER') == 'your_email@gmail.com' or
        env_vars.get('SMTP_PASS') == 'your_app_password_here'
    )
    
    if email_needs_config:
        print("\n   üìß Configurazione Email:")
        
        # Controlla se ha gi√† un'email valida
        if env_vars.get('SMTP_USER') and '@gmail.com' in env_vars.get('SMTP_USER') and env_vars.get('SMTP_USER') != 'your_email@gmail.com':
            print(f"   Email attuale: {env_vars['SMTP_USER']}")
            keep_email = input("   Mantenere questa email? (S/n): ").strip().lower()
            
            if keep_email == 'n':
                email_user, email_pass = get_gmail_app_password()
                if email_user and email_pass:
                    env_vars['SMTP_USER'] = email_user
                    env_vars['SMTP_PASS'] = email_pass
                    env_vars['SENDER_EMAIL'] = email_user
        else:
            email_user, email_pass = get_gmail_app_password()
            if email_user and email_pass:
                env_vars['SMTP_USER'] = email_user
                env_vars['SMTP_PASS'] = email_pass
                env_vars['SENDER_EMAIL'] = email_user
            else:
                print(f"   ‚ö†Ô∏è Email non configurata - dovrai configurarla manualmente")
    
    # Assicurati che SENDER_EMAIL sia uguale a SMTP_USER
    if env_vars.get('SMTP_USER') and (not env_vars.get('SENDER_EMAIL') or env_vars.get('SENDER_EMAIL') == 'your_email@gmail.com'):
        env_vars['SENDER_EMAIL'] = env_vars['SMTP_USER']
    
    # 3. MONGODB_URI
    if 'MONGODB_URI' in missing_vars or not env_vars.get('MONGODB_URI'):
        env_vars['MONGODB_URI'] = 'mongodb://localhost:27017/ProgettoTerapia'
        print(f"   ‚úÖ MongoDB URI: {env_vars['MONGODB_URI']}")
    
    # 4. PORTS
    if 'PORT' in missing_vars or not env_vars.get('PORT'):
        env_vars['PORT'] = '4000'
    
    if 'BACKEND_URL' in missing_vars or not env_vars.get('BACKEND_URL'):
        env_vars['BACKEND_URL'] = f"http://localhost:{env_vars['PORT']}"
    
    if 'FRONTEND_URL' in missing_vars or not env_vars.get('FRONTEND_URL'):
        env_vars['FRONTEND_URL'] = 'http://localhost:5173'
    
    # 5. NODE_ENV
    if 'NODE_ENV' in missing_vars or not env_vars.get('NODE_ENV'):
        env_vars['NODE_ENV'] = 'development'
    
    # 6. SMTP CONFIG
    if 'SMTP_HOST' in missing_vars or not env_vars.get('SMTP_HOST'):
        env_vars['SMTP_HOST'] = 'smtp.gmail.com'
    
    if 'SMTP_PORT' in missing_vars or not env_vars.get('SMTP_PORT'):
        env_vars['SMTP_PORT'] = '465'
    
    # ========================================
    # SCRIVI IL FILE .ENV RIPARATO
    # ========================================
    
    env_content = f"""# ================================
# PEPPER FEEL GOOD - CONFIGURATION
# Aggiornato automaticamente da setup.py
# Data: {time.strftime('%Y-%m-%d %H:%M:%S')}
# ================================

# DATABASE
MONGODB_URI={env_vars.get('MONGODB_URI', 'mongodb://localhost:27017/ProgettoTerapia')}
PORT={env_vars.get('PORT', '4000')}
NODE_ENV={env_vars.get('NODE_ENV', 'development')}

# SECURITY
JWT_SECRETE={env_vars.get('JWT_SECRETE', 'GENERATE_NEW_SECRET')}

# EMAIL (Gmail App Password)
# IMPORTANTE: Questa NON √® la tua password Gmail normale!
# √à una "App Password" generata su https://myaccount.google.com/apppasswords
SMTP_HOST={env_vars.get('SMTP_HOST', 'smtp.gmail.com')}
SMTP_PORT={env_vars.get('SMTP_PORT', '465')}
SMTP_USER={env_vars.get('SMTP_USER', 'your_email@gmail.com')}
SMTP_PASS={env_vars.get('SMTP_PASS', 'your_16_char_app_password')}
SENDER_EMAIL={env_vars.get('SENDER_EMAIL', env_vars.get('SMTP_USER', 'your_email@gmail.com'))}

# URLS
BACKEND_URL={env_vars.get('BACKEND_URL', 'http://localhost:4000')}
FRONTEND_URL={env_vars.get('FRONTEND_URL', 'http://localhost:5173')}
"""
    
    # Backup del vecchio file
    if env_file.exists():
        backup_file = env_file.parent / f".env.backup.{int(time.time())}"
        shutil.copy(env_file, backup_file)
        print(f"\n   üíæ Backup creato: {backup_file.name}")
    
    # Scrivi il nuovo file
    with open(env_file, 'w', encoding='utf-8') as f:
        f.write(env_content)
    
    print(f"\n   ‚úÖ File .env riparato con successo!")
    print(f"   üìù Percorso: {env_file}")
    
    # Mostra riepilogo finale
    print(f"\n   üìã RIEPILOGO CONFIGURAZIONE:")
    print(f"   " + "="*50)
    
    if vv_root and vv_root.exists():
        print(f"   ‚úÖ VibeVoice: {vv_root}")
    else:
        print(f"   ‚ùå VibeVoice: NON CONFIGURATO")
    
    if python_bin and python_bin.exists():
        print(f"   ‚úÖ Python: {python_bin}")
    else:
        print(f"   ‚ùå Python venv: NON CONFIGURATO")
    
    if env_vars.get('SMTP_USER') and env_vars.get('SMTP_USER') != 'your_email@gmail.com':
        print(f"   ‚úÖ Email: {env_vars.get('SMTP_USER')}")
    else:
        print(f"   ‚ö†Ô∏è Email: DA CONFIGURARE")
    
    print(f"   " + "="*50)
    
    return True

def run_command(command, cwd=None, shell=True, description="", show_output=False):
    try:
        if description:
            print(f"   ‚è≥ {description}...")
        
        if show_output:
            # Mostra l'output in tempo reale
            process = subprocess.Popen(
                command,
                cwd=cwd,
                shell=shell,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            
            for line in process.stdout:
                print(f"      {line.rstrip()}")
            
            process.wait()
            success = process.returncode == 0
            return success, ""
        else:
            result = subprocess.run(
                command, 
                cwd=cwd, 
                shell=shell, 
                check=True,
                capture_output=True,
                text=True
            )
            print(f"   ‚úÖ Completato!")
            return True, result.stdout
    except subprocess.CalledProcessError as e:
        print(f"   ‚ùå Errore: {e.stderr if hasattr(e, 'stderr') else str(e)}")
        return False, e.stderr if hasattr(e, 'stderr') else str(e)

def check_nodejs():
    """Verifica che Node.js sia installato"""
    try:
        result = subprocess.run(["node", "--version"], capture_output=True, text=True)
        version = result.stdout.strip()
        print(f"   ‚úÖ Node.js installato: {version}")
        return True
    except FileNotFoundError:
        print(f"   ‚ùå Node.js NON installato!")
        print(f"   üì• Scarica da: https://nodejs.org/")
        return False

def check_python():
    """Verifica che Python sia installato"""
    version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"   ‚úÖ Python installato: {version}")
    
    if sys.version_info < (3, 8):
        print(f"   ‚ö†Ô∏è ATTENZIONE: Python 3.8+ √® consigliato per VibeVoice")
        return False
    return True

def check_git():
    """Verifica che Git sia installato"""
    try:
        result = subprocess.run(["git", "--version"], capture_output=True, text=True)
        version = result.stdout.strip()
        print(f"   ‚úÖ Git installato: {version}")
        return True
    except FileNotFoundError:
        print(f"   ‚ö†Ô∏è Git NON installato!")
        print(f"   üí° Git √® necessario per clonare VibeVoice")
        print(f"   üì• Scarica da: https://git-scm.com/")
        return False

def check_nvidia_gpu():
    """Verifica se √® presente una GPU NVIDIA"""
    print("\n   üéÆ Rilevamento GPU NVIDIA...")
    
    try:
        # Prova con nvidia-smi (comando standard NVIDIA)
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=name,driver_version,memory.total", "--format=csv,noheader"],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode == 0 and result.stdout.strip():
            gpu_info = result.stdout.strip().split('\n')
            print(f"   ‚úÖ GPU NVIDIA rilevata!")
            for gpu in gpu_info:
                parts = gpu.split(',')
                if len(parts) >= 3:
                    name = parts[0].strip()
                    driver = parts[1].strip()
                    memory = parts[2].strip()
                    print(f"      ‚Ä¢ {name}")
                    print(f"      ‚Ä¢ Driver: {driver}")
                    print(f"      ‚Ä¢ VRAM: {memory}")
            return True, gpu_info[0].split(',')[0].strip()
        else:
            print(f"   ‚ÑπÔ∏è Nessuna GPU NVIDIA rilevata")
            return False, None
            
    except FileNotFoundError:
        print(f"   ‚ÑπÔ∏è nvidia-smi non trovato (normale se non hai GPU NVIDIA)")
        return False, None
    except Exception as e:
        print(f"   ‚ÑπÔ∏è Impossibile rilevare GPU: {e}")
        return False, None

def get_cuda_version():
    """Rileva la versione CUDA installata"""
    try:
        result = subprocess.run(
            ["nvcc", "--version"],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode == 0:
            # Estrai la versione CUDA dall'output
            match = re.search(r'release (\d+\.\d+)', result.stdout)
            if match:
                cuda_version = match.group(1)
                print(f"   ‚úÖ CUDA Toolkit installato: {cuda_version}")
                return cuda_version
    except:
        pass
    
    print(f"   ‚ÑπÔ∏è CUDA Toolkit non trovato (verr√† usata la versione bundled con PyTorch)")
    return None

def check_vibevoice(base_path):
    """Verifica se VibeVoice √® presente e correttamente strutturato"""
    vv_root = base_path / "VibeVoice"
    
    print("\n   üîç Verifica installazione VibeVoice...")
    
    if not vv_root.exists():
        print(f"   ‚ùå Cartella VibeVoice non trovata in: {vv_root}")
        return False, vv_root
    
    # Verifica struttura
    required_files = [
        "setup.py",
        "demo/realtime_model_inference_from_file.py",
    ]
    
    missing_files = []
    for file in required_files:
        if not (vv_root / file).exists():
            missing_files.append(file)
    
    if missing_files:
        print(f"   ‚ö†Ô∏è VibeVoice incompleto. File mancanti:")
        for f in missing_files:
            print(f"      ‚Ä¢ {f}")
        return False, vv_root
    
    print(f"   ‚úÖ VibeVoice trovato e completo")
    return True, vv_root

def clone_vibevoice(base_path):
    """Clona il repository VibeVoice"""
    vv_root = base_path / "VibeVoice"
    
    print("\n   üì• CLONAZIONE VIBEVOICE DA GITHUB")
    print("   " + "-"*50)
    print(f"   Repository: https://github.com/microsoft/VibeVoice.git")
    print(f"   Destinazione: {vv_root}")
    print(f"   ‚è≥ Questo richieder√† 2-5 minuti...")
    print()
    
    success, _ = run_command(
        "git clone https://github.com/microsoft/VibeVoice.git",
        cwd=str(base_path),
        description="Clonazione repository",
        show_output=True
    )
    
    return success

def install_pytorch(pip_path, has_gpu=False, cuda_version=None):
    """Installa PyTorch ottimizzato per la configurazione hardware"""
    
    print("\n   üî• INSTALLAZIONE PYTORCH")
    print("   " + "-"*50)
    
    if has_gpu:
        print(f"   üéÆ GPU NVIDIA rilevata ‚Üí Installazione versione GPU")
        print(f"   ‚ö° Questo accelerer√† ENORMEMENTE la generazione audio!")
        
        # Determina la versione CUDA da usare
        if cuda_version:
            cuda_major = cuda_version.split('.')[0]
            if int(cuda_major) >= 12:
                torch_cuda = "cu121"
            elif int(cuda_major) == 11:
                torch_cuda = "cu118"
            else:
                torch_cuda = "cu118"  # Default
        else:
            torch_cuda = "cu118"  # Default se CUDA non rilevato
        
        torch_install_cmd = f'"{pip_path}" install torch torchaudio --index-url https://download.pytorch.org/whl/{torch_cuda}'
        
        print(f"   üì¶ Versione: PyTorch con CUDA {torch_cuda}")
        print(f"   ‚è≥ Download in corso (pu√≤ richiedere 5-10 minuti)...")
        
    else:
        print(f"   üíª GPU non rilevata ‚Üí Installazione versione CPU")
        print(f"   ‚ö†Ô∏è La generazione audio sar√† pi√π lenta (1-2 min per storia)")
        
        choice = input("\n   ‚ùì Vuoi comunque installare la versione GPU manualmente? (s/N): ").strip().lower()
        
        if choice == 's':
            print(f"   üì¶ Installazione versione GPU (CUDA 11.8)...")
            torch_install_cmd = f'"{pip_path}" install torch torchaudio --index-url https://download.pytorch.org/whl/cu118'
        else:
            print(f"   üì¶ Installazione versione CPU...")
            torch_install_cmd = f'"{pip_path}" install torch torchaudio --index-url https://download.pytorch.org/whl/cpu'
        
        print(f"   ‚è≥ Download in corso (pu√≤ richiedere 5-10 minuti)...")
    
    success, _ = run_command(torch_install_cmd, description="", show_output=True)
    
    return success

def verify_pytorch_installation(python_bin):
    """Verifica che PyTorch sia installato correttamente"""
    print("\n   üîç Verifica installazione PyTorch...")
    
    verify_script = """
import torch
print(f"PyTorch Version: {torch.__version__}")
print(f"CUDA Available: {torch.cuda.is_available()}")
if torch.cuda.is_available():
    print(f"CUDA Version: {torch.version.cuda}")
    print(f"GPU Count: {torch.cuda.device_count()}")
    print(f"GPU Name: {torch.cuda.get_device_name(0)}")
else:
    print("Running on CPU")
"""
    
    try:
        result = subprocess.run(
            [str(python_bin), "-c", verify_script],
            capture_output=True,
            text=True,
            timeout=30
        )
        
        if result.returncode == 0:
            print("   " + "="*50)
            for line in result.stdout.strip().split('\n'):
                print(f"   ‚úÖ {line}")
            print("   " + "="*50)
            return True
        else:
            print(f"   ‚ùå Errore verifica: {result.stderr}")
            return False
    except Exception as e:
        print(f"   ‚ùå Errore: {e}")
        return False

def check_mongodb():
    """Verifica che MongoDB sia in esecuzione"""
    try:
        result = subprocess.run(
            ["mongo", "--eval", "db.version()"],
            capture_output=True,
            text=True,
            timeout=5
        )
        print(f"   ‚úÖ MongoDB raggiungibile")
        return True
    except:
        print(f"   ‚ö†Ô∏è MongoDB non raggiungibile (normale se non √® avviato)")
        return False

def get_gmail_app_password():
    """Guida l'utente a creare una App Password di Gmail"""
    print("\n   üìß CONFIGURAZIONE EMAIL GMAIL")
    print("   " + "-"*50)
    print("""
   ‚ö†Ô∏è IMPORTANTE: Non usare la tua password Gmail normale!
   
   üìù COME OTTENERE UNA APP PASSWORD:
   
   1. Vai su: https://myaccount.google.com/apppasswords
   
   2. Accedi con il tuo account Gmail
   
   3. Nella sezione "App passwords":
      ‚Ä¢ Nome app: "Pepper Feel Good"
      ‚Ä¢ Clicca "Crea"
   
   4. Google ti mostrer√† una password di 16 caratteri
      Esempio: "abcd efgh ijkl mnop"
   
   5. Copia quella password e incollala qui sotto
   
   üí° Nota: Gli spazi nella password non contano
   """)
    
    email = input("   üìß Inserisci la tua email Gmail: ").strip()
    
    print(f"\n   üîê Ora genera la App Password seguendo i passaggi sopra")
    app_password = input("   üîë Incolla qui la App Password (16 caratteri): ").strip()
    
    # Rimuovi spazi
    app_password = app_password.replace(" ", "")
    
    if len(app_password) != 16:
        print(f"   ‚ö†Ô∏è ATTENZIONE: La password dovrebbe essere 16 caratteri")
        print(f"   Lunghezza attuale: {len(app_password)} caratteri")
        confirm = input("   Continuare comunque? (s/N): ").strip().lower()
        if confirm != 's':
            return None, None
    
    return email, app_password

def setup():
    base_path = Path(__file__).parent.absolute()
    total_steps = 10
    
    print_header("Setup Pepper Feel Good", "üåà")
    print(f"üìç Percorso progetto: {base_path}\n")
    
    # STEP 0: Prerequisiti
    print_step(0, total_steps, "Verifica Prerequisiti")
    
    if not check_nodejs():
        print("\n‚õî ERRORE CRITICO: Installa Node.js prima di continuare!")
        input("Premi INVIO per uscire...")
        sys.exit(1)
    
    if not check_python():
        print("\n‚ö†Ô∏è ATTENZIONE: Versione Python non ottimale")
        choice = input("Continuare comunque? (s/N): ").strip().lower()
        if choice != 's':
            sys.exit(1)
    
    has_git = check_git()
    check_mongodb()
    
    # STEP 1: NODE.JS BACKEND
    print_step(1, total_steps, "Installazione Backend (Node.js)")
    
    server_path = base_path / "server"
    if server_path.exists():
        success, _ = run_command(
            "npm install", 
            cwd=str(server_path),
            description="Installazione moduli npm per il backend"
        )
        if not success:
            print("   ‚ö†Ô∏è Alcuni moduli potrebbero non essersi installati correttamente")
    else:
        print(f"   ‚ö†Ô∏è Cartella 'server' non trovata!")
    
    # STEP 2: NODE.JS FRONTEND
    print_step(2, total_steps, "Installazione Frontend (React)")
    
    client_path = base_path / "client"
    if client_path.exists():
        success, _ = run_command(
            "npm install",
            cwd=str(client_path),
            description="Installazione moduli npm per il frontend"
        )
        if not success:
            print("   ‚ö†Ô∏è Alcuni moduli potrebbero non essersi installati correttamente")
    else:
        print(f"   ‚ö†Ô∏è Cartella 'client' non trovata!")

    # STEP 3: VERIFICA/CLONA VIBEVOICE
    print_step(3, total_steps, "Verifica/Installazione VibeVoice")
    
    vv_exists, vv_root = check_vibevoice(base_path)
    
    if not vv_exists:
        if not has_git:
            print("\n   ‚õî Git non installato! Impossibile clonare VibeVoice automaticamente")
            print(f"\n   üìù ISTRUZIONI MANUALI:")
            print(f"   1. Installa Git da: https://git-scm.com/")
            print(f"   2. Esegui: git clone https://github.com/microsoft/VibeVoice.git")
            print(f"   3. Posiziona la cartella in: {vv_root}")
            print(f"   4. Riesegui questo script: python setup.py")
            vv_installed = False
        else:
            print(f"\n   VibeVoice non trovato. Vuoi clonarlo ora?")
            clone_choice = input("   ‚ùì Clonare VibeVoice da GitHub? (S/n): ").strip().lower()
            
            if clone_choice != 'n':
                if clone_vibevoice(base_path):
                    print(f"   ‚úÖ VibeVoice clonato con successo!")
                    vv_installed = True
                else:
                    print(f"   ‚ùå Errore durante la clonazione")
                    vv_installed = False
            else:
                print(f"   ‚è≠Ô∏è Salto installazione VibeVoice")
                vv_installed = False
    else:
        vv_installed = True
        print(f"   ‚úÖ VibeVoice gi√† installato")

    # STEP 4: RILEVAMENTO GPU
    print_step(4, total_steps, "Rilevamento Hardware (GPU)")
    
    has_nvidia_gpu, gpu_name = check_nvidia_gpu()
    cuda_version = get_cuda_version() if has_nvidia_gpu else None

    # STEP 5: PYTHON VENV
    print_step(5, total_steps, "Configurazione Ambiente Python (IA)")
    
    venv_path = vv_root / "env1"
    
    if vv_installed:
        # Crea VENV se non esiste
        if not venv_path.exists():
            print(f"   üêç Creazione Virtual Environment Python...")
            success, _ = run_command(
                f'"{sys.executable}" -m venv env1',
                cwd=str(vv_root),
                description="Creazione venv 'env1'"
            )
        else:
            print(f"   ‚úÖ Virtual Environment gi√† presente")
        
        # Determina i path in base al sistema operativo
        if platform.system() == "Windows":
            pip_path = venv_path / "Scripts" / "pip.exe"
            python_bin = venv_path / "Scripts" / "python.exe"
            activate_cmd = str(venv_path / "Scripts" / "activate.bat")
        else:
            pip_path = venv_path / "bin" / "pip"
            python_bin = venv_path / "bin" / "python"
            activate_cmd = f"source {venv_path / 'bin' / 'activate'}"

        # STEP 6: PYTORCH INSTALLATION
        print_step(6, total_steps, "Installazione PyTorch (AI Engine)")
        
        if pip_path.exists():
            # Upgrade pip
            run_command(
                f'"{pip_path}" install --upgrade pip',
                description="Aggiornamento pip"
            )
            
            # Installa PyTorch con rilevamento GPU
            pytorch_success = install_pytorch(pip_path, has_nvidia_gpu, cuda_version)
            
            if pytorch_success:
                # Verifica installazione
                verify_pytorch_installation(python_bin)
            else:
                print(f"   ‚ö†Ô∏è Problemi con l'installazione di PyTorch")
                vv_installed = False
        else:
            print(f"   ‚ùå pip non trovato in {pip_path}")
            vv_installed = False

        # STEP 7: VIBEVOICE INSTALLATION
        print_step(7, total_steps, "Installazione VibeVoice")
        
        if pip_path.exists() and vv_root.exists():
            # Installa VibeVoice
            success, _ = run_command(
                f'"{pip_path}" install -e .',
                cwd=str(vv_root),
                description="Installazione VibeVoice (modalit√† editable)",
                show_output=True
            )
            
            if success:
                print(f"   ‚úÖ VibeVoice configurato correttamente")
            else:
                print(f"   ‚ö†Ô∏è Problemi con l'installazione di VibeVoice")
                vv_installed = False
        else:
            print(f"   ‚ùå Path non validi per l'installazione VibeVoice")
            vv_installed = False
    else:
        print(f"   ‚è≠Ô∏è Salto configurazione Python (VibeVoice non installato)")

    # STEP 8: CARTELLE
    print_step(8, total_steps, "Creazione Struttura Cartelle")
    
    folders = [
        server_path / "uploads",
        server_path / "uploads" / "audio",
        server_path / "temp_audio"
    ]
    
    for folder in folders:
        if not folder.exists():
            folder.mkdir(parents=True, exist_ok=True)
            print(f"   üìÅ Creata: {folder.name}")
        else:
            print(f"   ‚úÖ Gi√† presente: {folder.name}")

    # STEP 9: FILE .ENV
    print_step(9, total_steps, "Configurazione File .env")
    
    env_file = server_path / ".env"
    
    # Determina i path per VibeVoice (se installato)
    if vv_installed and 'python_bin' in locals() and 'vv_root' in locals():
        repair_result = repair_env_file(
            env_file, 
            base_path, 
            vv_root=vv_root,
            python_bin=python_bin,
            venv_path=venv_path
        )
    else:
        repair_result = repair_env_file(env_file, base_path)
    
    # Se il repair non √® stato fatto o ha fallito, crea da zero
    if not repair_result and not env_file.exists():
        print("\n   üìù CREAZIONE FILE .ENV DA ZERO")
        print("   " + "-"*50)
        
        # Database
        print("\n   üóÑÔ∏è DATABASE:")
        mongo_uri = input("   MongoDB URI [mongodb://localhost:27017/ProgettoTerapia]: ").strip()
        if not mongo_uri:
            mongo_uri = "mongodb://localhost:27017/ProgettoTerapia"
        
        # Security
        print("\n   üîê SICUREZZA:")
        jwt_secret = input("   JWT Secret [genera automatico? Y/n]: ").strip().lower()
        if jwt_secret != 'n':
            import secrets
            jwt_secret = secrets.token_urlsafe(32)
            print(f"   ‚úÖ Generato: {jwt_secret}")
        else:
            jwt_secret = input("   Inserisci JWT Secret: ").strip()
        
        # Email
        email_user, email_pass = get_gmail_app_password()
        
        if not email_user or not email_pass:
            print(f"   ‚ö†Ô∏è Configurazione email saltata")
            email_user = "your_email@gmail.com"
            email_pass = "your_app_password_here"
        
        # Server ports
        print("\n   üåê SERVER:")
        backend_port = input("   Porta Backend [4000]: ").strip() or "4000"
        frontend_port = input("   Porta Frontend [5173]: ").strip() or "5173"
        
        # Path assoluti per VibeVoice
        if vv_installed and 'python_bin' in locals():
            if platform.system() == "Windows":
                vv_abs_path = str(vv_root).replace("\\", "/")
                python_abs_path = str(python_bin).replace("\\", "/")
            else:
                vv_abs_path = str(vv_root)
                python_abs_path = str(python_bin)
        else:
            vv_abs_path = "PATH_TO_VIBEVOICE_NOT_CONFIGURED"
            python_abs_path = "PATH_TO_PYTHON_NOT_CONFIGURED"

        env_content = f"""# ================================
# PEPPER FEEL GOOD - CONFIGURATION
# ================================

# DATABASE
MONGODB_URI={mongo_uri}
PORT={backend_port}
NODE_ENV=development

# SECURITY
JWT_SECRETE={jwt_secret}

# EMAIL (Gmail App Password)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=465
SMTP_USER={email_user}
SMTP_PASS={email_pass}
SENDER_EMAIL={email_user}

# URLS
BACKEND_URL=http://localhost:{backend_port}
FRONTEND_URL=http://localhost:{frontend_port}
"""
        
        with open(env_file, "w", encoding="utf-8") as f:
            f.write(env_content)
        
        print(f"\n   ‚úÖ File .env creato: {env_file}")
        
    # STEP 10: VERIFICA INSTALLAZIONE
    print_step(10, total_steps, "Verifica Installazione Finale")
    
    checks = {
        "Backend npm modules": (server_path / "node_modules").exists(),
        "Frontend npm modules": (client_path / "node_modules").exists(),
        "VibeVoice clonato": vv_root.exists(),
        "Python venv": venv_path.exists() if vv_installed else False,
        "PyTorch installato": vv_installed,
        "File .env": env_file.exists(),
        "Cartella uploads": (server_path / "uploads").exists(),
    }
    
    all_good = True
    print("\n   " + "="*50)
    for check_name, status in checks.items():
        emoji = "‚úÖ" if status else "‚ùå"
        print(f"   {emoji} {check_name}")
        if not status:
            all_good = False
    print("   " + "="*50)
    
    # ISTRUZIONI FINALI
    print("\n" + "="*60)
    if all_good:
        print("üéâ SETUP COMPLETATO CON SUCCESSO! üéâ")
    else:
        print("‚ö†Ô∏è SETUP COMPLETATO CON ALCUNI AVVISI")
    print("="*60)
    
    print(f"""
üìã PROSSIMI PASSI:

1Ô∏è‚É£ AVVIA MONGODB (se non √® gi√† in esecuzione):
   {'‚Ä¢ Windows: Servizio MongoDB o mongod.exe' if platform.system() == 'Windows' else '‚Ä¢ Linux/Mac: sudo systemctl start mongod'}

2Ô∏è‚É£ AVVIA IL BACKEND:
   cd {server_path.name}
   node server.js

3Ô∏è‚É£ AVVIA IL FRONTEND (nuovo terminale):
   cd {client_path.name}
   npm run dev

4Ô∏è‚É£ APRI IL BROWSER:
   http://localhost:{frontend_port if 'frontend_port' in locals() else '5173'}

""")
    
    if vv_installed:
        gpu_status = "üéÆ GPU NVIDIA" if has_nvidia_gpu else "üíª CPU"
        print(f"""üé§ CONFIGURAZIONE VIBEVOICE:
   Modalit√†: {gpu_status}
   Virtual Environment: {venv_path}
   Python: {python_bin if 'python_bin' in locals() else 'N/A'}
   
   Per testare manualmente:
     cd {vv_root}
     {activate_cmd if 'activate_cmd' in locals() else 'env1/Scripts/activate'}
     python demo/realtime_model_inference_from_file.py --help
""")
        
        if has_nvidia_gpu:
            print(f"""   ‚ö° ACCELERAZIONE GPU ATTIVA!
   La generazione audio sar√† molto pi√π veloce (~10-30 secondi)
   GPU: {gpu_name}
""")
        else:
            print(f"""   ‚ÑπÔ∏è MODALIT√Ä CPU
   La generazione audio richieder√† 1-2 minuti per storia
   
   üí° Per velocizzare, installa una GPU NVIDIA compatibile
""")
    else:
        print(f"""‚ö†Ô∏è VIBEVOICE NON CONFIGURATO:
   
   üìù OPZIONI:
   
   A) Installazione Automatica (raccomandato):
      1. Assicurati di avere Git installato
      2. Riesegui: python setup.py
      3. Quando richiesto, scegli 'S' per clonare VibeVoice
   
   B) Installazione Manuale:
      1. Apri terminale/cmd
      2. Vai nella cartella del progetto: cd "{base_path}"
      3. Clona: git clone https://github.com/microsoft/VibeVoice.git
      4. Riesegui: python setup.py
""")
    
    print("="*60)
    print("üåà Buon lavoro con Pepper Feel Good!")
    print("="*60 + "\n")
    
    if not all_good:
        print("üí° Suggerimento: Controlla i messaggi di errore sopra")
        print("   e risolvi i problemi prima di avviare l'applicazione.\n")

if __name__ == "__main__":
    try:
        setup()
    except KeyboardInterrupt:
        print("\n\n‚õî Setup interrotto dall'utente")
        sys.exit(0)
    except Exception as e:
        print(f"\n\n‚ùå ERRORE CRITICO: {e}")
        import traceback
        traceback.print_exc()
        input("\nPremi INVIO per uscire...")
        sys.exit(1)